# 单机数据库的实现

### 1. 数据库

Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：

在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库，dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。

在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针。该指针指向redisServer.db数组的其中一个元素。

#### 1.1 数据库键空间

Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）

> 使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：
>
> * 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。
> * 在读取一个键之后，服务器会更新键的LRU时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime <key> 命令可以查看键key的闲置时间。
> * 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。
> * 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键以及被修改过。
> * 服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。
> * 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。

#### 1.2 设置键的生存时间或过期时间

EXPIRE命令（秒）或者PEXPIRE命令（毫秒）以秒或者毫秒精度给数据库中的某个键设置过期时间。

TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间。返回-1表示该键不会过期。

redisDb结构的expires字典保存了数据库中所有键的过期时间，这个字典称为过期字典

* 过期字典的键是一个指针，这个指针指向键空间中的某个键对象
* 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

PERSIST命令可以移除一个键的过期时间

**过期键的判定**

1. 检查给定键是否存在于过期宝典：如果存在，那么取得键的过期时间。
2. 检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。

#### 1.3 过期删除策略

* 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。
* 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。
* 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

##### 1.3.1 定时删除

对内存最友好，对CPU最不友好。定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量

##### 1.3.2 惰性删除

对CPU友好，对内存最不友好。浪费太多内存，有内存泄露的危险

##### 1.3.3 定期删除

* 每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
* 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。

难点：确定删除操作执行的时长和频率。

#### 1.4 Redis的过期删除策略

惰性删除和定期删除

##### 1.4.1 惰性删除策略的实现

过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：

* 如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。
* 未过期，不做动作。

![](C:\Users\silverspoon\Documents\note\redis\惰性删除过程.png)

##### 1.4.2 定期删除策略的实现

redis.c/activeExprieCycle函数

每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，他在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。

activeExpireCycle函数的工作模式如下：

1. 每次运行时，从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键
2. 全集变量current_db会记录当前activeExpireCycle函数检查的精度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。
3. 随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。

#### 1.5 AOF、RDB和复制功能对过期键的处理

##### 1.5.1 生成RDB文件

在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

##### 1.5.2 载入RDB文件

在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：

* 以主服务器模式运行，在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入数据库
* 以从服务器模式运行，在载入RDB文件时，无论是否过期都会被载入数据库中。

##### 1.5.3 AOF文件写入

当服务器以AOF持久化模式运行时，如果数据库中的某个键过期了，但是还没有被删除，AOF文件不会因为这个过期键而产生任何影响

当过期键被删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。

##### 1.5.4 AOF重写

与生成RDB文件时类似。

##### 1.5.5 复制

当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制。

1. 主服务器在删除一个过期键之后，显示地向所有从服务器发送一个DEL命令，告诉从服务器删除这个过期键
2. 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会键过期键删除，而是继续像处理未过期的键一样来处理过期键
3. 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键

#### 1.6 数据库通知

键空间通知、键事件通知

notifyKeyspaceEvent函数执行的操作：

1. server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。
2. 如果给定的通知是服务器运行发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，允许的话就会构建并发送事件通知。
3. 最后，检测服务器是否允许发送键事件通知，允许的话就会构建并发送通知。

### 2. RDB持久化

SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。

BGSAVE命令会派生出一个子进程，然后又子进程负责创建RDB文件，服务器进程继续处理命令请求。

RDB文件的载入工作是在服务器启动时自动执行的。

因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：

* 如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。
* 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。

![](C:\Users\silverspoon\Documents\note\redis\RDB.png)

BGSAVE和BGREWRITEAOF两个命令不能同时执行：

* 如果BGSAVE正在执行，BGREWRITEAOF会被延迟到BGSAVE完成之后。
* 如果BGREWRITEAOF正在执行，BGSAVE会被服务器拒绝。

##### 2.1 自动间隔性保存

用户通过save选项设置多个保存条件，只要其中任意一个满足，服务器就会执行BGSAVE命令。

### 3. AOF持久化

AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。

#### 3.1 AOF持久化的实现

命令追加（append）、文件写入、文件同步（sync）

##### 3.1.1 命令追加

服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。

##### 3.1.2 AOF文件的写入与同步

Redis的服务器进程就是一个事件循环，这个循环中的文件时间负责接收客户端的命令请求，以及向客户端发送命令回复，而时间时间则负责执行像serverCron函数这样需要定时运行的函数。

在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。

flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定。

| appendfsync选项的值 | flushAppendOnlyFile函数的行为                                |
| ------------------- | ------------------------------------------------------------ |
| always              | 将aof_buf缓冲区中的所有内容写入并同步到AOF文件               |
| everysec            | 将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的 |
| no                  | 将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统来决定 |

appendfsync默认值为everysec。

#### 3.2 AOF文件的载入与数据还原

Redis读取AOF文件并还原数据库状态的详细步骤如下：

1. 创建一个不带网络连接的伪客户端：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。
2. 从AOF文件中分析并读取出一条写命令。
3. 使用伪客户端执行被读出的写命令。
4. 一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。

#### 3.3 AOF重写

虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为”AOF文件重写“， 但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。

首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。使用子进程进行AOF重写。在子进程执行AOF重写期间，服务器进程会将客户端发送的写命令追加到AOF重写缓冲区。

当子进程完成AOF重写工作之后，父进程会执行以下工作：

1. 将AOF重写缓冲区中的所有内容写入到新AOF文件中
2. 对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换

### 4. 事件

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：

* 文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
* 时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。

#### 4.1 文件事件

Redis基于Reactor模式开发了自己的网络事件处理器。

* 文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
* 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。

文件事件处理器由套接字、I/O多路复用程序、文件事件分派器以及事件处理器组成。

I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。

#### 4.2 时间事件

Redis的时间事件分为以下两类：

* 定时事件：让一段程序在指定的时间之后执行一次。
* 周期性时间：让一段程序每隔指定时间就执行一次。

一个时间事件有以下三个属性组成：

* id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。
* when：毫秒精度的UNIX时间戳，记录了时间事件的到达时间。
* timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。

一个时间事件是定时时间还是周期性事件取决于时间事件处理器的返回值：

* 返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再达到。
* 返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个时间在一段时间之后再次可达，并以这种方式一直更新并运行下去。

**实现**

> 服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的时间处理器。

serverCron函数：

> * 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。
> * 清理数据库中的过期键值对。
> * 关闭和清理连接失效的客户端。
> * 尝试进行AOF或RDB持久化操作。
> * 如果服务器是主服务器，那么对从服务器进行定期同步。
> * 如果处于集群模式，对集群进行定期同步和连接测试。
>
> Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。

### 5. 服务器

1. 读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。
2. 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。
3. 调用命令执行器，执行客户端指定的命令。

serverCron函数行为：

1. 更新服务器时间缓存。（适合对时间精确度不高的功能，100毫秒一次）
2. 更新LRU时钟（用于计算数据库键的空转时间，10秒更新一次）
3. 更新服务器每秒执行命令次数（使用数组保存之前的抽样结果）
4. 更新服务器内存峰值记录
5. 处理SIGTERM信号（收到SIGTERM信号时会打开服务器状态的shutdown_asap标识）
6. 管理客户端资源（clientsCron函数）
   * 如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端
   * 如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存
7. 管理数据库资源（过期删除策略）
8. 执行被延迟的BGREWRITEAOF
9. 检查持久化操作的运行状态
10. 将AOF缓冲区中的内容写入AOF文件
11. 关闭异步客户端（关闭那些输出缓冲区大小超出限制的客户端）
12. 增加cronloops计数器的值

**初始化服务器**

1. 初始化服务器状态结构
   * 设置服务器的运行ID
   * 设置服务器的默认运行频率
   * 设置服务器的默认配置文件路径
   * 设置服务器的运行架构
   * 设置服务器的默认端口号
   * 设置服务器的默认RDB持久化条件和AOF持久化条件
   * 初始化服务器的LRU时钟
   * 创建命令表
2. 载入配置选项
3. 初始化服务器数据结构
   * server.clients链表，记录了所有与服务器相连的客户端的状态结构。
   * server.db数组，包含了服务器的所有数据库。
   * 用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。
   * 用于执行Lua脚本的Lua环境server.lua。
   * 用于保存慢查询日志的server.slowlog属性。
4. 还原数据库状态
5. 执行事件循环

