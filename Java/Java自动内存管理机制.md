## Java虚拟机

### 一、 Java内存区域与内存溢出异常

#### 1. 程序计数器

> 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。java多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器。**因此该类内存区域为“线程私有”的内存**
>
> 如果线程正在执行一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果是正在执行的是Native方法，这个计数器值则为空（Undefined）。**此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**

#### 2.java虚拟机栈

> **该内存区域也是线程私有**
>
> 虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）[^1] 用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
>
> **局部变量表所需的内存空间在编译期间完成分配**
>
> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
>
> [^1]: 帧是方法运行期间的基础数据结构，在本书的第8章中会对帧进行详细讲解

#### 3.本地方法栈

> 本地方法栈是为虚拟机使用到的Native方法服务。
>
> *Sun HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一*
>
> 本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

#### 4.java堆

>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，主要用于存放对象实例。
>
>是Garbage Collected主要对象。

#### 5.方法区

> 该内存区域同样是所有线程共享的内存区域，主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
>
> 该内存区域GC的主要对象是针对常量池的回收和对类型的卸载。

#### 6.运行时常量池

> 运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，除此之外，运行期间也可以将新的常量放入池中。

#### 7.直接内存

> JDK1.4中新加入NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据。

#### 对象访问

> 使用句柄访问方式，java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。
>
> 使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（GC）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

> 使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。
>
> 使用直接指针访问的最大好处是速度更快，节省了一次指针定位的时间开销。

### 二、垃圾收集器与内存分配策略

#### 1.对象已死？

> 引用计数算法
>
> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象则为不再被使用的。
>
> **缺陷**：无法解决对象之间的相互循环引用的问题。
>
> ```java
> /**
>  * testGC()方法执行后，objectA和objectB会不会被GC呢？
>  */
> public class ReferenceCountingGC {
>     public Object instance = null;
>     private static final int _1MB = 1024 * 1024;
>     
>     private byte[] bigSize = new byte[2 * _1MB];
>     
>     public static void testGC() {
>         ReferenceCountingGC objA = new ReferenceCountingGC();
>         ReferenceCountingGC objB = new ReferenceCountingGC();
>         objA.instance = objB;
>         objB.instance = objA;
>         
>         objA = null;
>         objB = null;
>         
>         System.GC();
>     }
> }
> ```

#### 2.根搜索算法

> 通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可以用的。
>
> 在Java语言里，可作为GC Roots的对象包括如下：
>
> 1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象；
> 2. 方法区中的类静态属性引用的对象
> 3. 方法区中的常量引用的对象
> 4. 本地方法栈中JNI（即一般说的Native方法）的引用的对象

#### 3.扩充引用类型

> **强引用**：在程序代码中普遍存在，类似“Object obj = new Object()”这类的引用，只要强引用还在，GC永远不会回收该对象。
>
> **软引用**：描述一些还有用，但并非必需的对象。此类对象在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。JDK1.2之后，提供了**SoftReference**类实现软引用。
>
> **弱引用**：同软引用，只是引用强度更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。**WeakReference类**
>
> **虚引用**：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。*为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。**PhantomReference类**

#### 4.finalize()

> 如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，*筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”*；如果对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为**F-Queue**的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。（“执行”是指虚拟机会触发这个方法，但不承若会等待它运行结束，避免执行过慢或发生死循环）
>
> finalize（）能做的所有工作，使用try-finally或其他方式都可以做的更好、更及时，尽量避免使用该方法。

#### 5.回收方法区

> 主要回收内容：**废弃常量**和**无用的类**
>
> 无用的类：
>
>    	1. 该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。
>    	2. 加载该类的ClassLoader已经被回收。
>    	3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 三、垃圾收集算法

#### 1.标记-清楚算法

> 首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
>
> 缺点：效率问题：标记和清除过程的效率都不高；
>
> ​	空间问题：标记清除之后会产生大量不连续的内存碎片。

#### 2.复制算法

> 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。
>
> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。

#### 3.标记-整理算法

> 首先标记出所有需要回收的对象，然后将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 3.分代收集算法

> 根据对象的存活周期的不同将内存划分为几块，根据各个年代的特点采用最适当的收集算法。

### 四、垃圾收集器

#### 1.Serial收集器

> 单线程收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。（复制算法）
>
> 依然是虚拟机运行在Client模式下的默认新生代收集器，简单而高效（与其他收集器的单线程比）。

#### 2.ParNew收集器

> Serial收集器的多线程版本。
>
> 运行在Server模式下的虚拟机中首选的新生代收集器。HotSpot虚拟机中第一款真正意义上的并发收集器。[^2][^3]

[^2]: 并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
[^3]: 并发 ：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。

#### 3.Parallel Scavenge收集器

> Parallel Scavenge收集器使用复制算法，又是并行的多线程收集器。
>
> Parallel Scavenge收集器不同于其他的收集器关注于尽可能缩短垃圾收集时用户线程的停顿时间，主要是达到一个可控制的吞吐量[^4]。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
>
> -XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间，该参数的值是一个大于0的毫秒数。
>
> -XX:GCTimeRatio：控制吞吐量大小，该参数的值是一个大于0小于100的整数。默认值为99.

#### 4.Serial Old收集器

> Serial收集器的老年代版本，单线程收集器，使用“标记-整理”算法。同样主要用于Client模式下的虚拟机。
>
> 1. 在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用。
> 2. 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。

#### 5.Parallel Old收集器

> Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

#### 6.CMS收集器

> Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法。步骤如下：
>
> 1. 初始标记（CMS initial mark）
>
> 2. 并发标记（CMS concurrent mark）
>
> 3. 重新标记（CMS remark）
>
> 4. 并发清除（CMS concurrent sweep）
>
>    其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而 重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。
>
> **缺点**：
>
> 1. CMS收集器对CPU资源非常敏感。“增量式并发收集器”：在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些。
> 2. CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure“失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，CMS无法再本次收集中处理掉它们，只好留待下一次GC时再讲其清理掉。这一部分垃圾称为“浮动垃圾”。CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败。
> 3. 收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦。

#### 7.G1收集器

> 相比CMS收集器有两个显著的改进：
>
> 1. G1收集器是基于“标记-整理”算法实现的收集器。
> 2. 它可以非常精确地控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎是实时Java（RTSJ）的垃圾收集器的特征。
>
> G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的来由）。

#### 8.垃圾收集器参数总结

```
1. 1. UseSerialGC：使用Serial+Serial Old的收集器组合进行内存回收。
2. UseParNewGC：使用ParNew+Serial Old的收集器。
3. UseConcMarkSweepGC：使用ParNew+CMS+Serial Old收集器。其中Serial Old在CMS收集器出现Concurrent Mode Failure后使用。
4. UseParallelGC：使用Parallel Scavenge+Serial Old收集器。
5. UseParallelOldGC：使用Parallel Scavenge + Parallel Old收集器。
6. SurvivorRatio：新生代中Eden区域与Survivor区域的容量比值，默认为8.即Eden：Survivor=8:1.
7. PretenureSizeThreshold：直接晋升到老年代的对象大小。
8. MaxTenuringThreshold：晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就加1，当超过这个参数值时就进入老年代
9. UseAdaptiveSizePolicy：动态调整Java堆中各个区域的大小以及进入老年代的年龄。
10. HandlePromotionFailure：是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况。
11. ParallelGCThreads：设置并行GC时进行内存回收的线程数。
12. GCTimeRatio：GC时间占总时间的比率，默认值为99。仅在使用Parallel Scavenge收集器时生效。
13. MaxGCPauseMillis：设置GC的最大停顿时间。仅在Parallel Scavenge有效。
14. CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%。
15. UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集器后是否要进行一次内存碎片整理。
16. CMSFullGCsBeforeCompaction：设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。
```

### 五、内存分配与回收策略

#### 1. 对象优先在Eden分配

​	当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC

#### 2. 大对象直接进入老年代

​	大对象指需要大量连续内存空间的Java对象。

#### 3. 长期存活的对象将进入老年代

​	维持一个对象年龄（Age）计数器，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。

#### 4. 动态对象年龄判定

​	如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

#### 5. 空间分配担保

​	在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。

